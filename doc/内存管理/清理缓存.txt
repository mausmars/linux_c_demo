echo N > /proc/sys/vm/drop_caches , 当N数值不同时，
free –m存在差异
第一类单位参数：
1) -b, –bytes， 以Byte为单位显示内存使用情况
2) -k, –kilo， 以KB为单位， 这也是默认值
3) -m, –mega， 以MB为单位显示内容使用情况
4) -g, –giga， 以GB为单位显示内存使用情况

第二类参数：
1)、 -h, –human， 自动将数值转换为人类易读形式
2)、 -c, –count， 展示结果count次，需与-s配合使用
3)、 -s, –seconds， 动态刷新内存使用情况的间隔

free -m各字段含义
第一部分Mem行：
========================
total 内存总数: 3865M
used 已经使用的内存数: 1545M
free 空闲的内存数: 2320M
shared 多个进程共享的内存总额 196M
buffers Buffer 缓存内存数: 176M
cached Page 缓存内存数:569M
关系：total (3865M) = used(1545M) + free(2320M)
第二部分(-/+ buffers/cache):
========================
(-buffers/cache) used内存数：798M
(指的第一部分Mem行中的used – buffers – cached)
即为1545 – 176 – 569 = 800 取整时计算差异 2M

(+buffers/cache) free内存数: 3066M
(指的第一部分Mem行中的free + buffers + cached)
即为2320 + 176 + 569 = 3065 取整时计算差异 1M
第三部分是指交换分区
========================
当系统的物理内存不够用的时候，就需要将物理内存中的一部分空间释放出来，以供当前运行的程序使用。这些被释放的进程被临时保存到Swap空间中，等到那些程序要运行时，再从Swap分区中恢复保存的数据到内存中。这样，系统总是在物理内存不够时，才进行Swap交换。所以swap分区不被占用或者占用很少，说明现在系统内存够用，运行还算良好，不会影响系统运行

-----------------------------------------------------------
如果因为是应用有像内存泄露、溢出的问题，从swap的使用情况是可以比较快速可以判断的，但free上面反而比较难查看。相反，如果在这个时候，我们告诉用户，修改系统的一个值，
“可以”释放内存，free就大了。用户会怎么想？不会觉得操作系统“有问题”吗？所以说，既然核心是可以快速清空buffer或cache，也不难做到（这从上面的操作中可以明显看到），
但核心并没有这样做（默认值是0），我们就不应该随便去改变它。

一般情况下，应用在系统上稳定运行了，free值也会保持在一个稳定值的，虽然看上去可能比较小。当发生内存不足、应用获取不到可用内存、OOM错误等问题时，还是更应该去分析应用方面的原因，
如用户量太大导致内存不足、发生应用内存溢出等情况，否则，清空buffer，强制腾出free的大小，可能只是把问题给暂时屏蔽了。

排除内存不足的情况外，除非是在软件开发阶段，需要临时清掉buffer，以判断应用的内存使用情况；或应用已经不再提供支持，即使应用对内存的时候确实有问题，而且无法避免的情况下，
才考虑定时清空buffer。（可惜，这样的应用通常都是运行在老的操作系统版本上，上面的操作也解决不了）







