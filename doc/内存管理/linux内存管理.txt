https://dreamgoing.github.io/linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html
https://www.kernel.org/doc/gorman/html/understand/understand001.html
http://www.secretmango.com/jimb/Whitepapers/slabs/slab.html

基于linux内核2.6版本

内存管理的高效性：
减少了操作系统分配内存，回收内存的开销
减少了内存碎片，提高了内存有效利用率
对于频繁使用的数据结构，使用内存管理去缓存

--------------------------------------------
基础的概念
BIOS(Basic Input/Output System)：中的一些数据一般在物理地址前1MB, 主要职责为计算机启动引导时系统自检，并加载操作系统启动的引导程序

内核：通常启动之后的物理地址是BIOS之后从0x00100000地址开始 (低地址)

MMU(memory management unit):CPU的一个单独模块，用来将虚拟地址转换为实际物理地址的组件，MMU通常使用内存中的一个组件，通常称为页表(page table)或PTE(page table entry)来管理虚拟地址到实际物理地址的映射。（硬件层面）

PTE(page table entry)：页表存储着映射信息，页表实现了页表置换算法，用来存储最常用的页映射，即LRU(least recently used)算法。
当映射缺失时，则会向CPU发送一个Page Fault即 缺页中断, CPU则会在物理内存(RAM)中寻找一个空闲的页, 并更新PTE。如果没有可用的空闲页，则CPU会选择PTE页表中的页，
置换到磁盘上并在PTE页面设置标志，这就是通常所说的页面调度(paging)，将内存页换出到磁盘或者swap空间。（软件层面，虚拟内存）

linux使用三级页表完成虚拟地址到实际物理地址的转换，为了加速这样的转换通常的体系结构层面使用了TLB来加速转换

TLB(Translation lookaside buffer): 是保存虚拟地址到物理地址的一个缓存，是MMU的一部分，存储在CPU和CPU cache之间，有效的减少了通过转换去获取物理地址的次数。
--------------------------------------------
内存分配架构

用户内存空间
由低地址到高地址依次为:
1.可执行文件代码的内存映射, 代码段(text section)
2.可执行文件的已初始化全局变量的内存映射，数据段(data section)
3.可执行文件未初始化的全局变量，bbs段的零页(bbs segment)
4.内存堆区(heap)
5.共享内存段，C库，或一些动态链接库,内存映射文件mmap将内核中的内存映射到用户进程空间，减少了内核态向用户态copy的消耗
6.内存栈区(stack) 高地址 => 低地址

内核内存空间
区域 ZONE_DMA,ZONE_NORMAL,ZONE_HIGHEM, 在每个区域中又通过slab层来管理内存。
内核管理内存的最小单位是物理页，通常在32位体系结构中支持4kb的物理页，内核直接管理物理页，内核管理的内存是不会出现换出的情况的。

kmalloc kfree, vmalloc vfree
kmalloc: 返回一个指向内存块的指针，所分配的内存在物理上连续的
vmalloc：所分配的内存在虚拟地址空间上是连续的，并不会保证在物理RAM上是连续的。在性能上，vmalloc为了将物理上不连续的页转换成虚拟地址上连续的页，必须专门建立页表项，这就会导致TLB的缓存失效，影响性能。
因此只有在少数情况下才会使用vmalloc，例如将模块动态加载到内核中。

总而言之：整体架构上，对于用户内存空间linux使用我们所熟知的虚拟内存管理的方式对内存进行管理，而对于内核使用Slab或者vmalloc的方式对内存进行管理。在此之上，liunx统一使用Buddy System提供了更加灵活的内存管理方式。
--------------------------------------------
Slab & Buddy allocator
Slab allocator: 具有相同大小的内存集合，通过一次性申请较大的内存空间，并将其等分为大小相同的块，来避免内存碎片。
Buddy system 伙伴系统:即分配的每个对象都带有一个buddy伙伴，当对象被释放时，伙伴系统会将其内存进行合并。当有小对象需要分配内存时，伙伴系统将会把大内存块分割成小内存块分配出去。伙伴系统buddy system对内存块的切分合并的思想，主要为了内存分配和归还的复用（re-use）。

总而言之：
Slab：申请的大的内存块会被划分成相等大小的块，以链表的形式存储维护，不会对内存块进行合并和分隔，对于频繁固定大小内存的分配和释放十分高效。slab会以高速缓存组的形式管理诸如task struct,inode struct这些固定大小而又频繁使用的数据结构。
Buddy: 按需分配不同大小的内存，分配和归还涉及内存块的合并和分割
--------------------------------------------
Buddy allocator算法
Buddy allocator或Buddy system是一种经典内存分配算法, 分离适配(segregated fit), 其主要思想是将内存按2的幂次划分，并搜索其内存空间找到最佳适配的内存。搜索复杂度为O(logN)。其缺点是如果要分配66单位的大小，则需要划分出128大小的块。
Buddy allocator在linux系统中主要是为了分配动态大小的对象而设计的，对于固定大小且分配频率高的对象使用slab分配器。

--------------------------------------------
page&zone关系
Slab Buddy为linux内核管理内存的方式，在其底层对于每个物理页使用高速缓存组zone和物理页page的方式进行管理

=========================================================
虚拟内存管理

内存寻址
MMU是一种硬件电路实现，包含主要两个部件：分段部件，分页部件。
分段机制：将虚拟地址(逻辑地址)转化成线性地址
分页机制：将线性地址转化成物理地址









