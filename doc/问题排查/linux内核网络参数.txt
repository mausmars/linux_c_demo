https://blog.csdn.net/u010278923/article/details/102663535

今天在生产环境遇到了一个奇怪的网络现象，通过抓包发现，SYN 包没有 ACK。可以 ping 通，防火墙开放的情况下，基本确定对方服务器问题。
首先排除端口是否已经耗尽，发现仍有很多富余
那么可能就是 linux 内核网络参数 tcp_tw_recycle 捣鬼。登录对方主机发现这个参数的确被设置成 1。

$ sysctl -a|grep tcp_tw_recycle
net.ipv4.tcp_tw_recycle = 0
很多人对 tcp_tw_recycle 和 tcp_tw_reuse 区别不是很清楚。下面详细介绍一下。测试之前我们先将客户端的端口号范围限制一下

$ sysctl -w "net.ipv4.ip_local_port_range=32768 32768"
net.ipv4.ip_local_port_range = 32768 32768
只开放一个端口，然后访问任意一个服务，在 tcp_tw_reuse 和 tcp_tw_recycle 都关闭的情况下，可以看到服务只能访问一次，再次访问便报错。

如果开启 tcp_tw_reuse，那么便可以重复利用处于 time_wait 状态的连接。

而 tcp_tw_recycle 这个参数有点尴尬，4.x 内核版本之后这个参数已经被废弃了，可见这个参数有点鸡肋甚至是危险。
这个参数表明尽快的回收处于 time_wait 状态的连接，不用等两个 MSL 就关闭连接。但它的副作用是会拒绝所有比这个客户端时间戳更靠前的网络包。
如果大家没有理解，我举个例子，如果服务器记录了 10.10.10.10 这个机器发过来最新的数据包是 10:41 那么如果从 10.10.10.10 过来数据包是这个时间之前是话，这个包将会被拒绝。
那么好奇的读者又会问，这个包不应该是递增的吗？通常应该不会有问题，是这样，但如果是 NAT 的环境，你很难保障后端所有的机器的时钟是同步的，那么就会出现部分数据包被服务端拒绝的情况。
所以这个参数请谨慎使用，不建议开启！！！