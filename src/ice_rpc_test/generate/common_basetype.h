//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.7.6
//
// <auto-generated>
//
// Generated from file `common_basetype.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __common_basetype_h__
#define __common_basetype_h__

#include <IceUtil/PushDisableWarnings.h>
#include <Ice/ProxyF.h>
#include <Ice/ObjectF.h>
#include <Ice/ValueF.h>
#include <Ice/Exception.h>
#include <Ice/LocalObject.h>
#include <Ice/StreamHelpers.h>
#include <Ice/Comparable.h>
#include <Ice/Proxy.h>
#include <Ice/Object.h>
#include <Ice/GCObject.h>
#include <Ice/Value.h>
#include <Ice/Incoming.h>
#include <Ice/FactoryTableInit.h>
#include <IceUtil/ScopedArray.h>
#include <Ice/Optional.h>
#include <IceUtil/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 307
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 >= 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 6
#       error Ice patch level mismatch!
#   endif
#endif

#ifdef ICE_CPP11_MAPPING // C++11 mapping

namespace squarepro
{


namespace basetype
{

class ByteWrap;
class ShortWrap;
class IntWrap;
class LongWrap;
class FloatWrap;
class DoubleWrap;
class StringWrap;

}

}

namespace squarepro
{

namespace basetype
{

using ByteArray = ::std::vector<::Ice::Byte>;

using ShortArray = ::std::vector<short>;

using IntArray = ::std::vector<int>;

using LongArray = ::std::vector<long long int>;

using FloatArray = ::std::vector<float>;

using DoubleArray = ::std::vector<double>;

using StringArray = ::std::vector<::std::string>;

using Object1Array = ::std::vector<::std::shared_ptr<::Ice::Value>>;

using ObjectPrx1Array = ::std::vector<::std::shared_ptr<::Ice::ObjectPrx>>;

using ByteLList = ::std::vector<::Ice::Byte>;

using ShortLList = ::std::vector<short>;

using IntLList = ::std::vector<int>;

using LongLList = ::std::vector<long long int>;

using FloatLList = ::std::vector<float>;

using DoubleLList = ::std::vector<double>;

using StringLList = ::std::vector<::std::string>;

using ObjectLList = ::std::vector<::std::shared_ptr<::Ice::Value>>;

using ObjectPrxLList = ::std::vector<::std::shared_ptr<::Ice::ObjectPrx>>;

using ByteAList = ::std::vector<::Ice::Byte>;

using ShortAList = ::std::vector<short>;

using IntAList = ::std::vector<int>;

using LongAList = ::std::vector<long long int>;

using FloatAList = ::std::vector<float>;

using DoubleAList = ::std::vector<double>;

using StringAList = ::std::vector<::std::string>;

using ObjectAList = ::std::vector<::std::shared_ptr<::Ice::Value>>;

using ObjectPrxAList = ::std::vector<::std::shared_ptr<::Ice::ObjectPrx>>;

using StringObjectHMap = ::std::map<::std::string, ::std::shared_ptr<::Ice::Value>>;

using IntObjectHMap = ::std::map<int, ::std::shared_ptr<::Ice::Value>>;

using LongObjectHMap = ::std::map<long long int, ::std::shared_ptr<::Ice::Value>>;

using StringObjectPrxHMap = ::std::map<::std::string, ::std::shared_ptr<::Ice::ObjectPrx>>;

using IntObjectPrxHMap = ::std::map<int, ::std::shared_ptr<::Ice::ObjectPrx>>;

using LongObjectPrxHMap = ::std::map<long long int, ::std::shared_ptr<::Ice::ObjectPrx>>;

using StringObjectCMap = ::std::map<::std::string, ::std::shared_ptr<::Ice::Value>>;

using LongObjectCMap = ::std::map<long long int, ::std::shared_ptr<::Ice::Value>>;

using IntObjectCMap = ::std::map<int, ::std::shared_ptr<::Ice::Value>>;

using StringObjectPrxCMap = ::std::map<::std::string, ::std::shared_ptr<::Ice::ObjectPrx>>;

using LongObjectPrxCMap = ::std::map<long long int, ::std::shared_ptr<::Ice::ObjectPrx>>;

using IntObjectPrxCMap = ::std::map<int, ::std::shared_ptr<::Ice::ObjectPrx>>;

}

}

namespace squarepro
{

namespace basetype
{

class ByteWrap : public ::Ice::ValueHelper<ByteWrap, ::Ice::Value>
{
public:

    virtual ~ByteWrap();

    ByteWrap() = default;

    ByteWrap(const ByteWrap&) = default;
    ByteWrap(ByteWrap&&) = default;
    ByteWrap& operator=(const ByteWrap&) = default;
    ByteWrap& operator=(ByteWrap&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit ByteWrap(::Ice::Byte value) :
        value(value)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::Ice::Byte&> ice_tuple() const
    {
        return std::tie(value);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::Ice::Byte value;
};

/// \cond INTERNAL
static ByteWrap _iceS_ByteWrap_init;
/// \endcond

class ShortWrap : public ::Ice::ValueHelper<ShortWrap, ::Ice::Value>
{
public:

    virtual ~ShortWrap();

    ShortWrap() = default;

    ShortWrap(const ShortWrap&) = default;
    ShortWrap(ShortWrap&&) = default;
    ShortWrap& operator=(const ShortWrap&) = default;
    ShortWrap& operator=(ShortWrap&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit ShortWrap(short value) :
        value(value)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const short&> ice_tuple() const
    {
        return std::tie(value);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    short value;
};

class IntWrap : public ::Ice::ValueHelper<IntWrap, ::Ice::Value>
{
public:

    virtual ~IntWrap();

    IntWrap() = default;

    IntWrap(const IntWrap&) = default;
    IntWrap(IntWrap&&) = default;
    IntWrap& operator=(const IntWrap&) = default;
    IntWrap& operator=(IntWrap&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit IntWrap(int value) :
        value(value)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const int&> ice_tuple() const
    {
        return std::tie(value);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    int value;
};

class LongWrap : public ::Ice::ValueHelper<LongWrap, ::Ice::Value>
{
public:

    virtual ~LongWrap();

    LongWrap() = default;

    LongWrap(const LongWrap&) = default;
    LongWrap(LongWrap&&) = default;
    LongWrap& operator=(const LongWrap&) = default;
    LongWrap& operator=(LongWrap&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit LongWrap(long long int value) :
        value(value)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const long long int&> ice_tuple() const
    {
        return std::tie(value);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    long long int value;
};

class FloatWrap : public ::Ice::ValueHelper<FloatWrap, ::Ice::Value>
{
public:

    virtual ~FloatWrap();

    FloatWrap() = default;

    FloatWrap(const FloatWrap&) = default;
    FloatWrap(FloatWrap&&) = default;
    FloatWrap& operator=(const FloatWrap&) = default;
    FloatWrap& operator=(FloatWrap&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit FloatWrap(float value) :
        value(value)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const float&> ice_tuple() const
    {
        return std::tie(value);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    float value;
};

class DoubleWrap : public ::Ice::ValueHelper<DoubleWrap, ::Ice::Value>
{
public:

    virtual ~DoubleWrap();

    DoubleWrap() = default;

    DoubleWrap(const DoubleWrap&) = default;
    DoubleWrap(DoubleWrap&&) = default;
    DoubleWrap& operator=(const DoubleWrap&) = default;
    DoubleWrap& operator=(DoubleWrap&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit DoubleWrap(double value) :
        value(value)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const double&> ice_tuple() const
    {
        return std::tie(value);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    double value;
};

class StringWrap : public ::Ice::ValueHelper<StringWrap, ::Ice::Value>
{
public:

    virtual ~StringWrap();

    StringWrap() = default;

    StringWrap(const StringWrap&) = default;
    StringWrap(StringWrap&&) = default;
    StringWrap& operator=(const StringWrap&) = default;
    StringWrap& operator=(StringWrap&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit StringWrap(const ::std::string& value) :
        value(value)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&> ice_tuple() const
    {
        return std::tie(value);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::string value;
};

}

}

namespace squarepro
{

namespace basetype
{

}

}

/// \cond STREAM
namespace Ice
{

template<typename S>
struct StreamReader<::squarepro::basetype::ByteWrap, S>
{
    static void read(S* istr, ::squarepro::basetype::ByteWrap& v)
    {
        istr->readAll(v.value);
    }
};

template<typename S>
struct StreamReader<::squarepro::basetype::ShortWrap, S>
{
    static void read(S* istr, ::squarepro::basetype::ShortWrap& v)
    {
        istr->readAll(v.value);
    }
};

template<typename S>
struct StreamReader<::squarepro::basetype::IntWrap, S>
{
    static void read(S* istr, ::squarepro::basetype::IntWrap& v)
    {
        istr->readAll(v.value);
    }
};

template<typename S>
struct StreamReader<::squarepro::basetype::LongWrap, S>
{
    static void read(S* istr, ::squarepro::basetype::LongWrap& v)
    {
        istr->readAll(v.value);
    }
};

template<typename S>
struct StreamReader<::squarepro::basetype::FloatWrap, S>
{
    static void read(S* istr, ::squarepro::basetype::FloatWrap& v)
    {
        istr->readAll(v.value);
    }
};

template<typename S>
struct StreamReader<::squarepro::basetype::DoubleWrap, S>
{
    static void read(S* istr, ::squarepro::basetype::DoubleWrap& v)
    {
        istr->readAll(v.value);
    }
};

template<typename S>
struct StreamReader<::squarepro::basetype::StringWrap, S>
{
    static void read(S* istr, ::squarepro::basetype::StringWrap& v)
    {
        istr->readAll(v.value);
    }
};

}
/// \endcond

/// \cond INTERNAL
namespace squarepro
{

/// \cond INTERNAL
namespace basetype
{

using ByteWrapPtr = ::std::shared_ptr<ByteWrap>;

using ShortWrapPtr = ::std::shared_ptr<ShortWrap>;

using IntWrapPtr = ::std::shared_ptr<IntWrap>;

using LongWrapPtr = ::std::shared_ptr<LongWrap>;

using FloatWrapPtr = ::std::shared_ptr<FloatWrap>;

using DoubleWrapPtr = ::std::shared_ptr<DoubleWrap>;

using StringWrapPtr = ::std::shared_ptr<StringWrap>;

}
/// \endcond

}
/// \endcond

#else // C++98 mapping

namespace IceProxy
{

namespace squarepro
{

namespace basetype
{

class ByteWrap;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< ByteWrap>&);
::IceProxy::Ice::Object* upCast(ByteWrap*);
/// \endcond

class ShortWrap;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< ShortWrap>&);
::IceProxy::Ice::Object* upCast(ShortWrap*);
/// \endcond

class IntWrap;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< IntWrap>&);
::IceProxy::Ice::Object* upCast(IntWrap*);
/// \endcond

class LongWrap;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< LongWrap>&);
::IceProxy::Ice::Object* upCast(LongWrap*);
/// \endcond

class FloatWrap;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< FloatWrap>&);
::IceProxy::Ice::Object* upCast(FloatWrap*);
/// \endcond

class DoubleWrap;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< DoubleWrap>&);
::IceProxy::Ice::Object* upCast(DoubleWrap*);
/// \endcond

class StringWrap;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< StringWrap>&);
::IceProxy::Ice::Object* upCast(StringWrap*);
/// \endcond

}

}

}

namespace squarepro
{

namespace basetype
{

class ByteWrap;
/// \cond INTERNAL
::Ice::Object* upCast(ByteWrap*);
/// \endcond
typedef ::IceInternal::Handle< ByteWrap> ByteWrapPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::squarepro::basetype::ByteWrap> ByteWrapPrx;
typedef ByteWrapPrx ByteWrapPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(ByteWrapPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class ShortWrap;
/// \cond INTERNAL
::Ice::Object* upCast(ShortWrap*);
/// \endcond
typedef ::IceInternal::Handle< ShortWrap> ShortWrapPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::squarepro::basetype::ShortWrap> ShortWrapPrx;
typedef ShortWrapPrx ShortWrapPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(ShortWrapPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class IntWrap;
/// \cond INTERNAL
::Ice::Object* upCast(IntWrap*);
/// \endcond
typedef ::IceInternal::Handle< IntWrap> IntWrapPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::squarepro::basetype::IntWrap> IntWrapPrx;
typedef IntWrapPrx IntWrapPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(IntWrapPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class LongWrap;
/// \cond INTERNAL
::Ice::Object* upCast(LongWrap*);
/// \endcond
typedef ::IceInternal::Handle< LongWrap> LongWrapPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::squarepro::basetype::LongWrap> LongWrapPrx;
typedef LongWrapPrx LongWrapPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(LongWrapPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class FloatWrap;
/// \cond INTERNAL
::Ice::Object* upCast(FloatWrap*);
/// \endcond
typedef ::IceInternal::Handle< FloatWrap> FloatWrapPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::squarepro::basetype::FloatWrap> FloatWrapPrx;
typedef FloatWrapPrx FloatWrapPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(FloatWrapPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class DoubleWrap;
/// \cond INTERNAL
::Ice::Object* upCast(DoubleWrap*);
/// \endcond
typedef ::IceInternal::Handle< DoubleWrap> DoubleWrapPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::squarepro::basetype::DoubleWrap> DoubleWrapPrx;
typedef DoubleWrapPrx DoubleWrapPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(DoubleWrapPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class StringWrap;
/// \cond INTERNAL
::Ice::Object* upCast(StringWrap*);
/// \endcond
typedef ::IceInternal::Handle< StringWrap> StringWrapPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::squarepro::basetype::StringWrap> StringWrapPrx;
typedef StringWrapPrx StringWrapPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(StringWrapPtr&, const ::Ice::ObjectPtr&);
/// \endcond

}

}

namespace squarepro
{

namespace basetype
{

typedef ::std::vector< ::Ice::Byte> ByteArray;

typedef ::std::vector< ::Ice::Short> ShortArray;

typedef ::std::vector< ::Ice::Int> IntArray;

typedef ::std::vector< ::Ice::Long> LongArray;

typedef ::std::vector< ::Ice::Float> FloatArray;

typedef ::std::vector< ::Ice::Double> DoubleArray;

typedef ::std::vector< ::std::string> StringArray;

typedef ::std::vector< ::Ice::ObjectPtr> Object1Array;

typedef ::std::vector< ::Ice::ObjectPrx> ObjectPrx1Array;

typedef ::std::vector< ::Ice::Byte> ByteLList;

typedef ::std::vector< ::Ice::Short> ShortLList;

typedef ::std::vector< ::Ice::Int> IntLList;

typedef ::std::vector< ::Ice::Long> LongLList;

typedef ::std::vector< ::Ice::Float> FloatLList;

typedef ::std::vector< ::Ice::Double> DoubleLList;

typedef ::std::vector< ::std::string> StringLList;

typedef ::std::vector< ::Ice::ObjectPtr> ObjectLList;

typedef ::std::vector< ::Ice::ObjectPrx> ObjectPrxLList;

typedef ::std::vector< ::Ice::Byte> ByteAList;

typedef ::std::vector< ::Ice::Short> ShortAList;

typedef ::std::vector< ::Ice::Int> IntAList;

typedef ::std::vector< ::Ice::Long> LongAList;

typedef ::std::vector< ::Ice::Float> FloatAList;

typedef ::std::vector< ::Ice::Double> DoubleAList;

typedef ::std::vector< ::std::string> StringAList;

typedef ::std::vector< ::Ice::ObjectPtr> ObjectAList;

typedef ::std::vector< ::Ice::ObjectPrx> ObjectPrxAList;

typedef ::std::map< ::std::string, ::Ice::ObjectPtr> StringObjectHMap;

typedef ::std::map< ::Ice::Int, ::Ice::ObjectPtr> IntObjectHMap;

typedef ::std::map< ::Ice::Long, ::Ice::ObjectPtr> LongObjectHMap;

typedef ::std::map< ::std::string, ::Ice::ObjectPrx> StringObjectPrxHMap;

typedef ::std::map< ::Ice::Int, ::Ice::ObjectPrx> IntObjectPrxHMap;

typedef ::std::map< ::Ice::Long, ::Ice::ObjectPrx> LongObjectPrxHMap;

typedef ::std::map< ::std::string, ::Ice::ObjectPtr> StringObjectCMap;

typedef ::std::map< ::Ice::Long, ::Ice::ObjectPtr> LongObjectCMap;

typedef ::std::map< ::Ice::Int, ::Ice::ObjectPtr> IntObjectCMap;

typedef ::std::map< ::std::string, ::Ice::ObjectPrx> StringObjectPrxCMap;

typedef ::std::map< ::Ice::Long, ::Ice::ObjectPrx> LongObjectPrxCMap;

typedef ::std::map< ::Ice::Int, ::Ice::ObjectPrx> IntObjectPrxCMap;

}

}

namespace squarepro
{

namespace basetype
{

}

}

namespace IceProxy
{

namespace squarepro
{

namespace basetype
{

class ByteWrap : public virtual ::Ice::Proxy<ByteWrap, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class ShortWrap : public virtual ::Ice::Proxy<ShortWrap, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class IntWrap : public virtual ::Ice::Proxy<IntWrap, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class LongWrap : public virtual ::Ice::Proxy<LongWrap, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class FloatWrap : public virtual ::Ice::Proxy<FloatWrap, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class DoubleWrap : public virtual ::Ice::Proxy<DoubleWrap, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class StringWrap : public virtual ::Ice::Proxy<StringWrap, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

}

}

}

namespace squarepro
{

namespace basetype
{

class ByteWrap : public virtual ::Ice::Object
{
public:

    typedef ByteWrapPrx ProxyType;
    typedef ByteWrapPtr PointerType;

    virtual ~ByteWrap();

    ByteWrap()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit ByteWrap(::Ice::Byte value) :
        value(value)
    {
    }

#ifdef ICE_CPP11_COMPILER
    ByteWrap(const ByteWrap&) = default;
    ByteWrap& operator=(const ByteWrap&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::Ice::Byte value;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_ByteWrap_init = ::squarepro::basetype::ByteWrap::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const ByteWrap& lhs, const ByteWrap& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const ByteWrap& lhs, const ByteWrap& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class ShortWrap : public virtual ::Ice::Object
{
public:

    typedef ShortWrapPrx ProxyType;
    typedef ShortWrapPtr PointerType;

    virtual ~ShortWrap();

    ShortWrap()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit ShortWrap(::Ice::Short value) :
        value(value)
    {
    }

#ifdef ICE_CPP11_COMPILER
    ShortWrap(const ShortWrap&) = default;
    ShortWrap& operator=(const ShortWrap&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::Ice::Short value;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_ShortWrap_init = ::squarepro::basetype::ShortWrap::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const ShortWrap& lhs, const ShortWrap& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const ShortWrap& lhs, const ShortWrap& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class IntWrap : public virtual ::Ice::Object
{
public:

    typedef IntWrapPrx ProxyType;
    typedef IntWrapPtr PointerType;

    virtual ~IntWrap();

    IntWrap()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit IntWrap(::Ice::Int value) :
        value(value)
    {
    }

#ifdef ICE_CPP11_COMPILER
    IntWrap(const IntWrap&) = default;
    IntWrap& operator=(const IntWrap&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::Ice::Int value;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_IntWrap_init = ::squarepro::basetype::IntWrap::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const IntWrap& lhs, const IntWrap& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const IntWrap& lhs, const IntWrap& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class LongWrap : public virtual ::Ice::Object
{
public:

    typedef LongWrapPrx ProxyType;
    typedef LongWrapPtr PointerType;

    virtual ~LongWrap();

    LongWrap()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit LongWrap(::Ice::Long value) :
        value(value)
    {
    }

#ifdef ICE_CPP11_COMPILER
    LongWrap(const LongWrap&) = default;
    LongWrap& operator=(const LongWrap&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::Ice::Long value;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_LongWrap_init = ::squarepro::basetype::LongWrap::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const LongWrap& lhs, const LongWrap& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const LongWrap& lhs, const LongWrap& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class FloatWrap : public virtual ::Ice::Object
{
public:

    typedef FloatWrapPrx ProxyType;
    typedef FloatWrapPtr PointerType;

    virtual ~FloatWrap();

    FloatWrap()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit FloatWrap(::Ice::Float value) :
        value(value)
    {
    }

#ifdef ICE_CPP11_COMPILER
    FloatWrap(const FloatWrap&) = default;
    FloatWrap& operator=(const FloatWrap&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::Ice::Float value;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_FloatWrap_init = ::squarepro::basetype::FloatWrap::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const FloatWrap& lhs, const FloatWrap& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const FloatWrap& lhs, const FloatWrap& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class DoubleWrap : public virtual ::Ice::Object
{
public:

    typedef DoubleWrapPrx ProxyType;
    typedef DoubleWrapPtr PointerType;

    virtual ~DoubleWrap();

    DoubleWrap()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit DoubleWrap(::Ice::Double value) :
        value(value)
    {
    }

#ifdef ICE_CPP11_COMPILER
    DoubleWrap(const DoubleWrap&) = default;
    DoubleWrap& operator=(const DoubleWrap&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::Ice::Double value;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_DoubleWrap_init = ::squarepro::basetype::DoubleWrap::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const DoubleWrap& lhs, const DoubleWrap& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const DoubleWrap& lhs, const DoubleWrap& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class StringWrap : public virtual ::Ice::Object
{
public:

    typedef StringWrapPrx ProxyType;
    typedef StringWrapPtr PointerType;

    virtual ~StringWrap();

    StringWrap()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit StringWrap(const ::std::string& value) :
        value(value)
    {
    }

#ifdef ICE_CPP11_COMPILER
    StringWrap(const StringWrap&) = default;
    StringWrap& operator=(const StringWrap&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::std::string value;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_StringWrap_init = ::squarepro::basetype::StringWrap::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const StringWrap& lhs, const StringWrap& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const StringWrap& lhs, const StringWrap& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

}

}

/// \cond STREAM
namespace Ice
{

template<typename S>
struct StreamWriter< ::squarepro::basetype::ByteWrap, S>
{
    static void write(S* ostr, const ::squarepro::basetype::ByteWrap& v)
    {
        ostr->write(v.value);
    }
};

template<typename S>
struct StreamReader< ::squarepro::basetype::ByteWrap, S>
{
    static void read(S* istr, ::squarepro::basetype::ByteWrap& v)
    {
        istr->read(v.value);
    }
};

template<typename S>
struct StreamWriter< ::squarepro::basetype::ShortWrap, S>
{
    static void write(S* ostr, const ::squarepro::basetype::ShortWrap& v)
    {
        ostr->write(v.value);
    }
};

template<typename S>
struct StreamReader< ::squarepro::basetype::ShortWrap, S>
{
    static void read(S* istr, ::squarepro::basetype::ShortWrap& v)
    {
        istr->read(v.value);
    }
};

template<typename S>
struct StreamWriter< ::squarepro::basetype::IntWrap, S>
{
    static void write(S* ostr, const ::squarepro::basetype::IntWrap& v)
    {
        ostr->write(v.value);
    }
};

template<typename S>
struct StreamReader< ::squarepro::basetype::IntWrap, S>
{
    static void read(S* istr, ::squarepro::basetype::IntWrap& v)
    {
        istr->read(v.value);
    }
};

template<typename S>
struct StreamWriter< ::squarepro::basetype::LongWrap, S>
{
    static void write(S* ostr, const ::squarepro::basetype::LongWrap& v)
    {
        ostr->write(v.value);
    }
};

template<typename S>
struct StreamReader< ::squarepro::basetype::LongWrap, S>
{
    static void read(S* istr, ::squarepro::basetype::LongWrap& v)
    {
        istr->read(v.value);
    }
};

template<typename S>
struct StreamWriter< ::squarepro::basetype::FloatWrap, S>
{
    static void write(S* ostr, const ::squarepro::basetype::FloatWrap& v)
    {
        ostr->write(v.value);
    }
};

template<typename S>
struct StreamReader< ::squarepro::basetype::FloatWrap, S>
{
    static void read(S* istr, ::squarepro::basetype::FloatWrap& v)
    {
        istr->read(v.value);
    }
};

template<typename S>
struct StreamWriter< ::squarepro::basetype::DoubleWrap, S>
{
    static void write(S* ostr, const ::squarepro::basetype::DoubleWrap& v)
    {
        ostr->write(v.value);
    }
};

template<typename S>
struct StreamReader< ::squarepro::basetype::DoubleWrap, S>
{
    static void read(S* istr, ::squarepro::basetype::DoubleWrap& v)
    {
        istr->read(v.value);
    }
};

template<typename S>
struct StreamWriter< ::squarepro::basetype::StringWrap, S>
{
    static void write(S* ostr, const ::squarepro::basetype::StringWrap& v)
    {
        ostr->write(v.value);
    }
};

template<typename S>
struct StreamReader< ::squarepro::basetype::StringWrap, S>
{
    static void read(S* istr, ::squarepro::basetype::StringWrap& v)
    {
        istr->read(v.value);
    }
};

}
/// \endcond

namespace squarepro
{

namespace basetype
{

}

}

#endif

#include <IceUtil/PopDisableWarnings.h>
#endif
