//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.7.6
//
// <auto-generated>
//
// Generated from file `server_model.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#include "server_model.h"
#include <IceUtil/PushDisableWarnings.h>
#include <Ice/LocalException.h>
#include <Ice/ValueFactory.h>
#include <Ice/OutgoingAsync.h>
#include <Ice/InputStream.h>
#include <Ice/OutputStream.h>
#include <IceUtil/PopDisableWarnings.h>

#if defined(_MSC_VER)
#   pragma warning(disable:4458) // declaration of ... hides class member
#elif defined(__clang__)
#   pragma clang diagnostic ignored "-Wshadow"
#elif defined(__GNUC__)
#   pragma GCC diagnostic ignored "-Wshadow"
#endif

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 307
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 >= 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 6
#       error Ice patch level mismatch!
#   endif
#endif

#ifdef ICE_CPP11_MAPPING // C++11 mapping

namespace
{

const ::IceInternal::DefaultValueFactoryInit<::squarepro::model::UserHero> iceC_squarepro_model_UserHero_init("::squarepro::model::UserHero");

const ::IceInternal::DefaultValueFactoryInit<::squarepro::model::MatchParams> iceC_squarepro_model_MatchParams_init("::squarepro::model::MatchParams");

const ::IceInternal::DefaultValueFactoryInit<::squarepro::model::UserTroop> iceC_squarepro_model_UserTroop_init("::squarepro::model::UserTroop");

const ::IceInternal::DefaultValueFactoryInit<::squarepro::model::BattleInfo> iceC_squarepro_model_BattleInfo_init("::squarepro::model::BattleInfo");

const ::IceInternal::DefaultValueFactoryInit<::squarepro::model::BattleTeam> iceC_squarepro_model_BattleTeam_init("::squarepro::model::BattleTeam");

const ::IceInternal::DefaultValueFactoryInit<::squarepro::model::UserStatistics> iceC_squarepro_model_UserStatistics_init("::squarepro::model::UserStatistics");

}

squarepro::model::UserHero::~UserHero()
{
}

const ::std::string&
squarepro::model::UserHero::ice_staticId()
{
    static const ::std::string typeId = "::squarepro::model::UserHero";
    return typeId;
}

squarepro::model::MatchParams::~MatchParams()
{
}

const ::std::string&
squarepro::model::MatchParams::ice_staticId()
{
    static const ::std::string typeId = "::squarepro::model::MatchParams";
    return typeId;
}

squarepro::model::UserTroop::~UserTroop()
{
}

const ::std::string&
squarepro::model::UserTroop::ice_staticId()
{
    static const ::std::string typeId = "::squarepro::model::UserTroop";
    return typeId;
}

squarepro::model::BattleInfo::~BattleInfo()
{
}

const ::std::string&
squarepro::model::BattleInfo::ice_staticId()
{
    static const ::std::string typeId = "::squarepro::model::BattleInfo";
    return typeId;
}

squarepro::model::BattleTeam::~BattleTeam()
{
}

const ::std::string&
squarepro::model::BattleTeam::ice_staticId()
{
    static const ::std::string typeId = "::squarepro::model::BattleTeam";
    return typeId;
}

squarepro::model::UserStatistics::~UserStatistics()
{
}

const ::std::string&
squarepro::model::UserStatistics::ice_staticId()
{
    static const ::std::string typeId = "::squarepro::model::UserStatistics";
    return typeId;
}

#else // C++98 mapping

namespace
{

namespace
{

}

}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::squarepro::model::upCast(UserHero* p) { return p; }

void
::IceProxy::squarepro::model::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< UserHero>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new UserHero;
        v->_copyFrom(proxy);
    }
}
/// \endcond

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::squarepro::model::UserHero::_newInstance() const
{
    return new UserHero;
}
/// \endcond

const ::std::string&
IceProxy::squarepro::model::UserHero::ice_staticId()
{
    return ::squarepro::model::UserHero::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::squarepro::model::upCast(MatchParams* p) { return p; }

void
::IceProxy::squarepro::model::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< MatchParams>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new MatchParams;
        v->_copyFrom(proxy);
    }
}
/// \endcond

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::squarepro::model::MatchParams::_newInstance() const
{
    return new MatchParams;
}
/// \endcond

const ::std::string&
IceProxy::squarepro::model::MatchParams::ice_staticId()
{
    return ::squarepro::model::MatchParams::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::squarepro::model::upCast(UserTroop* p) { return p; }

void
::IceProxy::squarepro::model::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< UserTroop>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new UserTroop;
        v->_copyFrom(proxy);
    }
}
/// \endcond

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::squarepro::model::UserTroop::_newInstance() const
{
    return new UserTroop;
}
/// \endcond

const ::std::string&
IceProxy::squarepro::model::UserTroop::ice_staticId()
{
    return ::squarepro::model::UserTroop::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::squarepro::model::upCast(BattleInfo* p) { return p; }

void
::IceProxy::squarepro::model::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< BattleInfo>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new BattleInfo;
        v->_copyFrom(proxy);
    }
}
/// \endcond

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::squarepro::model::BattleInfo::_newInstance() const
{
    return new BattleInfo;
}
/// \endcond

const ::std::string&
IceProxy::squarepro::model::BattleInfo::ice_staticId()
{
    return ::squarepro::model::BattleInfo::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::squarepro::model::upCast(BattleTeam* p) { return p; }

void
::IceProxy::squarepro::model::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< BattleTeam>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new BattleTeam;
        v->_copyFrom(proxy);
    }
}
/// \endcond

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::squarepro::model::BattleTeam::_newInstance() const
{
    return new BattleTeam;
}
/// \endcond

const ::std::string&
IceProxy::squarepro::model::BattleTeam::ice_staticId()
{
    return ::squarepro::model::BattleTeam::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::squarepro::model::upCast(UserStatistics* p) { return p; }

void
::IceProxy::squarepro::model::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< UserStatistics>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new UserStatistics;
        v->_copyFrom(proxy);
    }
}
/// \endcond

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::squarepro::model::UserStatistics::_newInstance() const
{
    return new UserStatistics;
}
/// \endcond

const ::std::string&
IceProxy::squarepro::model::UserStatistics::ice_staticId()
{
    return ::squarepro::model::UserStatistics::ice_staticId();
}

squarepro::model::UserHero::~UserHero()
{
}

/// \cond INTERNAL
::Ice::Object* squarepro::model::upCast(UserHero* p) { return p; }

/// \endcond
::Ice::ObjectPtr
squarepro::model::UserHero::ice_clone() const
{
    ::Ice::Object* p = new UserHero(*this);
    return p;
}

namespace
{
const ::std::string iceC_squarepro_model_UserHero_ids[2] =
{
    "::Ice::Object",
    "::squarepro::model::UserHero"
};

}

bool
squarepro::model::UserHero::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_squarepro_model_UserHero_ids, iceC_squarepro_model_UserHero_ids + 2, s);
}

::std::vector< ::std::string>
squarepro::model::UserHero::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_squarepro_model_UserHero_ids[0], &iceC_squarepro_model_UserHero_ids[2]);
}

const ::std::string&
squarepro::model::UserHero::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
squarepro::model::UserHero::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::squarepro::model::UserHero";
    return typeId;
#else
    return iceC_squarepro_model_UserHero_ids[1];
#endif
}

/// \cond STREAM
void
squarepro::model::UserHero::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< UserHero, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
squarepro::model::UserHero::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< UserHero, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

namespace
{
const ::IceInternal::DefaultValueFactoryInit< ::squarepro::model::UserHero> iceC_squarepro_model_UserHero_init("::squarepro::model::UserHero");
}

::Ice::ValueFactoryPtr
squarepro::model::UserHero::ice_factory()
{
    return ::IceInternal::factoryTable->getValueFactory(::squarepro::model::UserHero::ice_staticId());
}

/// \cond INTERNAL
void
squarepro::model::_icePatchObjectPtr(UserHeroPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = UserHeroPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(UserHero::ice_staticId(), v);
    }
}
/// \endcond

squarepro::model::MatchParams::~MatchParams()
{
}

/// \cond INTERNAL
::Ice::Object* squarepro::model::upCast(MatchParams* p) { return p; }

/// \endcond
::Ice::ObjectPtr
squarepro::model::MatchParams::ice_clone() const
{
    ::Ice::Object* p = new MatchParams(*this);
    return p;
}

namespace
{
const ::std::string iceC_squarepro_model_MatchParams_ids[2] =
{
    "::Ice::Object",
    "::squarepro::model::MatchParams"
};

}

bool
squarepro::model::MatchParams::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_squarepro_model_MatchParams_ids, iceC_squarepro_model_MatchParams_ids + 2, s);
}

::std::vector< ::std::string>
squarepro::model::MatchParams::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_squarepro_model_MatchParams_ids[0], &iceC_squarepro_model_MatchParams_ids[2]);
}

const ::std::string&
squarepro::model::MatchParams::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
squarepro::model::MatchParams::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::squarepro::model::MatchParams";
    return typeId;
#else
    return iceC_squarepro_model_MatchParams_ids[1];
#endif
}

/// \cond STREAM
void
squarepro::model::MatchParams::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< MatchParams, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
squarepro::model::MatchParams::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< MatchParams, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

namespace
{
const ::IceInternal::DefaultValueFactoryInit< ::squarepro::model::MatchParams> iceC_squarepro_model_MatchParams_init("::squarepro::model::MatchParams");
}

::Ice::ValueFactoryPtr
squarepro::model::MatchParams::ice_factory()
{
    return ::IceInternal::factoryTable->getValueFactory(::squarepro::model::MatchParams::ice_staticId());
}

/// \cond INTERNAL
void
squarepro::model::_icePatchObjectPtr(MatchParamsPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = MatchParamsPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(MatchParams::ice_staticId(), v);
    }
}
/// \endcond

squarepro::model::UserTroop::~UserTroop()
{
}

/// \cond INTERNAL
::Ice::Object* squarepro::model::upCast(UserTroop* p) { return p; }

/// \endcond

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4589)
#endif
::Ice::ObjectPtr
squarepro::model::UserTroop::ice_clone() const
{
    ::Ice::Object* p = new UserTroop(*this);
    return p;
}
#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

namespace
{
const ::std::string iceC_squarepro_model_UserTroop_ids[2] =
{
    "::Ice::Object",
    "::squarepro::model::UserTroop"
};

}

bool
squarepro::model::UserTroop::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_squarepro_model_UserTroop_ids, iceC_squarepro_model_UserTroop_ids + 2, s);
}

::std::vector< ::std::string>
squarepro::model::UserTroop::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_squarepro_model_UserTroop_ids[0], &iceC_squarepro_model_UserTroop_ids[2]);
}

const ::std::string&
squarepro::model::UserTroop::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
squarepro::model::UserTroop::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::squarepro::model::UserTroop";
    return typeId;
#else
    return iceC_squarepro_model_UserTroop_ids[1];
#endif
}

void
squarepro::model::UserTroop::_iceGcVisitMembers(::IceInternal::GCVisitor& v_)
{
    {
        for(::squarepro::model::UserHeroLList::iterator _i0 = heros.begin(); _i0 != heros.end(); ++_i0)
        {
            if((*_i0))
            {
                if((::squarepro::model::upCast((*_i0).get())->_iceGcVisit(v_)))
                {
                    (*_i0) = 0;
                }
            }
        }
    }
    if(matchParams)
    {
        if((::squarepro::model::upCast(matchParams.get())->_iceGcVisit(v_)))
        {
            matchParams = 0;
        }
    }
}

/// \cond STREAM
void
squarepro::model::UserTroop::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< UserTroop, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
squarepro::model::UserTroop::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< UserTroop, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

namespace
{
const ::IceInternal::DefaultValueFactoryInit< ::squarepro::model::UserTroop> iceC_squarepro_model_UserTroop_init("::squarepro::model::UserTroop");
}

::Ice::ValueFactoryPtr
squarepro::model::UserTroop::ice_factory()
{
    return ::IceInternal::factoryTable->getValueFactory(::squarepro::model::UserTroop::ice_staticId());
}

/// \cond INTERNAL
void
squarepro::model::_icePatchObjectPtr(UserTroopPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = UserTroopPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(UserTroop::ice_staticId(), v);
    }
}
/// \endcond

squarepro::model::BattleInfo::~BattleInfo()
{
}

/// \cond INTERNAL
::Ice::Object* squarepro::model::upCast(BattleInfo* p) { return p; }

/// \endcond
::Ice::ObjectPtr
squarepro::model::BattleInfo::ice_clone() const
{
    ::Ice::Object* p = new BattleInfo(*this);
    return p;
}

namespace
{
const ::std::string iceC_squarepro_model_BattleInfo_ids[2] =
{
    "::Ice::Object",
    "::squarepro::model::BattleInfo"
};

}

bool
squarepro::model::BattleInfo::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_squarepro_model_BattleInfo_ids, iceC_squarepro_model_BattleInfo_ids + 2, s);
}

::std::vector< ::std::string>
squarepro::model::BattleInfo::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_squarepro_model_BattleInfo_ids[0], &iceC_squarepro_model_BattleInfo_ids[2]);
}

const ::std::string&
squarepro::model::BattleInfo::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
squarepro::model::BattleInfo::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::squarepro::model::BattleInfo";
    return typeId;
#else
    return iceC_squarepro_model_BattleInfo_ids[1];
#endif
}

/// \cond STREAM
void
squarepro::model::BattleInfo::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< BattleInfo, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
squarepro::model::BattleInfo::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< BattleInfo, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

namespace
{
const ::IceInternal::DefaultValueFactoryInit< ::squarepro::model::BattleInfo> iceC_squarepro_model_BattleInfo_init("::squarepro::model::BattleInfo");
}

::Ice::ValueFactoryPtr
squarepro::model::BattleInfo::ice_factory()
{
    return ::IceInternal::factoryTable->getValueFactory(::squarepro::model::BattleInfo::ice_staticId());
}

/// \cond INTERNAL
void
squarepro::model::_icePatchObjectPtr(BattleInfoPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = BattleInfoPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(BattleInfo::ice_staticId(), v);
    }
}
/// \endcond

squarepro::model::BattleTeam::~BattleTeam()
{
}

/// \cond INTERNAL
::Ice::Object* squarepro::model::upCast(BattleTeam* p) { return p; }

/// \endcond

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4589)
#endif
::Ice::ObjectPtr
squarepro::model::BattleTeam::ice_clone() const
{
    ::Ice::Object* p = new BattleTeam(*this);
    return p;
}
#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

namespace
{
const ::std::string iceC_squarepro_model_BattleTeam_ids[2] =
{
    "::Ice::Object",
    "::squarepro::model::BattleTeam"
};

}

bool
squarepro::model::BattleTeam::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_squarepro_model_BattleTeam_ids, iceC_squarepro_model_BattleTeam_ids + 2, s);
}

::std::vector< ::std::string>
squarepro::model::BattleTeam::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_squarepro_model_BattleTeam_ids[0], &iceC_squarepro_model_BattleTeam_ids[2]);
}

const ::std::string&
squarepro::model::BattleTeam::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
squarepro::model::BattleTeam::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::squarepro::model::BattleTeam";
    return typeId;
#else
    return iceC_squarepro_model_BattleTeam_ids[1];
#endif
}

void
squarepro::model::BattleTeam::_iceGcVisitMembers(::IceInternal::GCVisitor& v_)
{
    if(userTroop)
    {
        if((::squarepro::model::upCast(userTroop.get())->_iceGcVisit(v_)))
        {
            userTroop = 0;
        }
    }
}

/// \cond STREAM
void
squarepro::model::BattleTeam::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< BattleTeam, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
squarepro::model::BattleTeam::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< BattleTeam, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

namespace
{
const ::IceInternal::DefaultValueFactoryInit< ::squarepro::model::BattleTeam> iceC_squarepro_model_BattleTeam_init("::squarepro::model::BattleTeam");
}

::Ice::ValueFactoryPtr
squarepro::model::BattleTeam::ice_factory()
{
    return ::IceInternal::factoryTable->getValueFactory(::squarepro::model::BattleTeam::ice_staticId());
}

/// \cond INTERNAL
void
squarepro::model::_icePatchObjectPtr(BattleTeamPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = BattleTeamPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(BattleTeam::ice_staticId(), v);
    }
}
/// \endcond

squarepro::model::UserStatistics::~UserStatistics()
{
}

/// \cond INTERNAL
::Ice::Object* squarepro::model::upCast(UserStatistics* p) { return p; }

/// \endcond

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4589)
#endif
::Ice::ObjectPtr
squarepro::model::UserStatistics::ice_clone() const
{
    ::Ice::Object* p = new UserStatistics(*this);
    return p;
}
#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

namespace
{
const ::std::string iceC_squarepro_model_UserStatistics_ids[2] =
{
    "::Ice::Object",
    "::squarepro::model::UserStatistics"
};

}

bool
squarepro::model::UserStatistics::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_squarepro_model_UserStatistics_ids, iceC_squarepro_model_UserStatistics_ids + 2, s);
}

::std::vector< ::std::string>
squarepro::model::UserStatistics::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_squarepro_model_UserStatistics_ids[0], &iceC_squarepro_model_UserStatistics_ids[2]);
}

const ::std::string&
squarepro::model::UserStatistics::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
squarepro::model::UserStatistics::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::squarepro::model::UserStatistics";
    return typeId;
#else
    return iceC_squarepro_model_UserStatistics_ids[1];
#endif
}

void
squarepro::model::UserStatistics::_iceGcVisitMembers(::IceInternal::GCVisitor& v_)
{
    {
        for(::squarepro::model::UserHeroLList::iterator _i0 = heros.begin(); _i0 != heros.end(); ++_i0)
        {
            if((*_i0))
            {
                if((::squarepro::model::upCast((*_i0).get())->_iceGcVisit(v_)))
                {
                    (*_i0) = 0;
                }
            }
        }
    }
}

/// \cond STREAM
void
squarepro::model::UserStatistics::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< UserStatistics, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
squarepro::model::UserStatistics::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< UserStatistics, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

namespace
{
const ::IceInternal::DefaultValueFactoryInit< ::squarepro::model::UserStatistics> iceC_squarepro_model_UserStatistics_init("::squarepro::model::UserStatistics");
}

::Ice::ValueFactoryPtr
squarepro::model::UserStatistics::ice_factory()
{
    return ::IceInternal::factoryTable->getValueFactory(::squarepro::model::UserStatistics::ice_staticId());
}

/// \cond INTERNAL
void
squarepro::model::_icePatchObjectPtr(UserStatisticsPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = UserStatisticsPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(UserStatistics::ice_staticId(), v);
    }
}
/// \endcond

namespace Ice
{
}

#endif
