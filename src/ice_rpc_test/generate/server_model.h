//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.7.6
//
// <auto-generated>
//
// Generated from file `server_model.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __server_model_h__
#define __server_model_h__

#include <IceUtil/PushDisableWarnings.h>
#include <Ice/ProxyF.h>
#include <Ice/ObjectF.h>
#include <Ice/ValueF.h>
#include <Ice/Exception.h>
#include <Ice/LocalObject.h>
#include <Ice/StreamHelpers.h>
#include <Ice/Comparable.h>
#include <Ice/Proxy.h>
#include <Ice/Object.h>
#include <Ice/GCObject.h>
#include <Ice/Value.h>
#include <Ice/Incoming.h>
#include <Ice/FactoryTableInit.h>
#include <IceUtil/ScopedArray.h>
#include <Ice/Optional.h>
#include "common_basetype.h"
#include <IceUtil/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 307
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 >= 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 6
#       error Ice patch level mismatch!
#   endif
#endif

#ifdef ICE_CPP11_MAPPING // C++11 mapping

namespace squarepro
{


namespace model
{

class UserTroop;
class UserHero;
class BattleTeam;
class MatchParams;
class BattleInfo;
class UserStatistics;

}

}

namespace squarepro
{

namespace model
{

using UserTroopLList = ::std::vector<::std::shared_ptr<UserTroop>>;

using UserHeroLList = ::std::vector<::std::shared_ptr<UserHero>>;

using BattleTeamLList = ::std::vector<::std::shared_ptr<BattleTeam>>;

}

}

namespace squarepro
{

namespace model
{

class UserHero : public ::Ice::ValueHelper<UserHero, ::Ice::Value>
{
public:

    virtual ~UserHero();

    UserHero() = default;

    UserHero(const UserHero&) = default;
    UserHero(UserHero&&) = default;
    UserHero& operator=(const UserHero&) = default;
    UserHero& operator=(UserHero&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    UserHero(int hid, int level) :
        hid(hid),
        level(level)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const int&, const int&> ice_tuple() const
    {
        return std::tie(hid, level);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    int hid;
    int level;
};

/// \cond INTERNAL
static UserHero _iceS_UserHero_init;
/// \endcond

class MatchParams : public ::Ice::ValueHelper<MatchParams, ::Ice::Value>
{
public:

    virtual ~MatchParams();

    MatchParams() = default;

    MatchParams(const MatchParams&) = default;
    MatchParams(MatchParams&&) = default;
    MatchParams& operator=(const MatchParams&) = default;
    MatchParams& operator=(MatchParams&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    MatchParams(int matchPoolId, int expectPoolId, int matchBattleType, int arenaScore, int winCount, int failCount, bool botFixedName, bool onlyBot, int correctDifficulty, long long int activityId, int activityConfigId, const ::std::string& faceToken) :
        matchPoolId(matchPoolId),
        expectPoolId(expectPoolId),
        matchBattleType(matchBattleType),
        arenaScore(arenaScore),
        winCount(winCount),
        failCount(failCount),
        botFixedName(botFixedName),
        onlyBot(onlyBot),
        correctDifficulty(correctDifficulty),
        activityId(activityId),
        activityConfigId(activityConfigId),
        faceToken(faceToken)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const int&, const int&, const int&, const int&, const int&, const int&, const bool&, const bool&, const int&, const long long int&, const int&, const ::std::string&> ice_tuple() const
    {
        return std::tie(matchPoolId, expectPoolId, matchBattleType, arenaScore, winCount, failCount, botFixedName, onlyBot, correctDifficulty, activityId, activityConfigId, faceToken);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    int matchPoolId;
    int expectPoolId;
    int matchBattleType;
    int arenaScore;
    int winCount;
    int failCount;
    bool botFixedName;
    bool onlyBot;
    int correctDifficulty;
    long long int activityId;
    int activityConfigId;
    ::std::string faceToken;
};

class UserTroop : public ::Ice::ValueHelper<UserTroop, ::Ice::Value>
{
public:

    virtual ~UserTroop();

    UserTroop() = default;

    UserTroop(const UserTroop&) = default;
    UserTroop(UserTroop&&) = default;
    UserTroop& operator=(const UserTroop&) = default;
    UserTroop& operator=(UserTroop&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    UserTroop(long long int userId, const ::std::string& name, const ::std::string& icon, int level, int playerType, int leaderId, int leaderSkill, const ::squarepro::model::UserHeroLList& heros, int difficulty, const ::std::string& logicNodeId, const ::std::shared_ptr<::squarepro::model::MatchParams>& matchParams) :
        userId(userId),
        name(name),
        icon(icon),
        level(level),
        playerType(playerType),
        leaderId(leaderId),
        leaderSkill(leaderSkill),
        heros(heros),
        difficulty(difficulty),
        logicNodeId(logicNodeId),
        matchParams(matchParams)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const long long int&, const ::std::string&, const ::std::string&, const int&, const int&, const int&, const int&, const ::squarepro::model::UserHeroLList&, const int&, const ::std::string&, const ::std::shared_ptr<::squarepro::model::MatchParams>&> ice_tuple() const
    {
        return std::tie(userId, name, icon, level, playerType, leaderId, leaderSkill, heros, difficulty, logicNodeId, matchParams);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    long long int userId;
    ::std::string name;
    ::std::string icon;
    int level;
    int playerType;
    int leaderId;
    int leaderSkill;
    ::squarepro::model::UserHeroLList heros;
    int difficulty;
    ::std::string logicNodeId;
    ::std::shared_ptr<::squarepro::model::MatchParams> matchParams;
};

class BattleInfo : public ::Ice::ValueHelper<BattleInfo, ::Ice::Value>
{
public:

    virtual ~BattleInfo();

    BattleInfo() = default;

    BattleInfo(const BattleInfo&) = default;
    BattleInfo(BattleInfo&&) = default;
    BattleInfo& operator=(const BattleInfo&) = default;
    BattleInfo& operator=(BattleInfo&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    BattleInfo(const ::std::string& host, int port, long long int battleId) :
        host(host),
        port(port),
        battleId(battleId)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const int&, const long long int&> ice_tuple() const
    {
        return std::tie(host, port, battleId);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::string host;
    int port;
    long long int battleId;
};

class BattleTeam : public ::Ice::ValueHelper<BattleTeam, ::Ice::Value>
{
public:

    virtual ~BattleTeam();

    BattleTeam() = default;

    BattleTeam(const BattleTeam&) = default;
    BattleTeam(BattleTeam&&) = default;
    BattleTeam& operator=(const BattleTeam&) = default;
    BattleTeam& operator=(BattleTeam&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit BattleTeam(const ::std::shared_ptr<::squarepro::model::UserTroop>& userTroop) :
        userTroop(userTroop)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::shared_ptr<::squarepro::model::UserTroop>&> ice_tuple() const
    {
        return std::tie(userTroop);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::shared_ptr<::squarepro::model::UserTroop> userTroop;
};

class UserStatistics : public ::Ice::ValueHelper<UserStatistics, ::Ice::Value>
{
public:

    virtual ~UserStatistics();

    UserStatistics() = default;

    UserStatistics(const UserStatistics&) = default;
    UserStatistics(UserStatistics&&) = default;
    UserStatistics& operator=(const UserStatistics&) = default;
    UserStatistics& operator=(UserStatistics&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    UserStatistics(int round, int eliminate, int skill, int lordskill, int level, const ::squarepro::model::UserHeroLList& heros, int arenaScore, int difficulty, int conwins) :
        round(round),
        eliminate(eliminate),
        skill(skill),
        lordskill(lordskill),
        level(level),
        heros(heros),
        arenaScore(arenaScore),
        difficulty(difficulty),
        conwins(conwins)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const int&, const int&, const int&, const int&, const int&, const ::squarepro::model::UserHeroLList&, const int&, const int&, const int&> ice_tuple() const
    {
        return std::tie(round, eliminate, skill, lordskill, level, heros, arenaScore, difficulty, conwins);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    int round;
    int eliminate;
    int skill;
    int lordskill;
    int level;
    ::squarepro::model::UserHeroLList heros;
    int arenaScore;
    int difficulty;
    int conwins;
};

}

}

namespace squarepro
{

namespace model
{

}

}

/// \cond STREAM
namespace Ice
{

template<typename S>
struct StreamReader<::squarepro::model::UserHero, S>
{
    static void read(S* istr, ::squarepro::model::UserHero& v)
    {
        istr->readAll(v.hid, v.level);
    }
};

template<typename S>
struct StreamReader<::squarepro::model::MatchParams, S>
{
    static void read(S* istr, ::squarepro::model::MatchParams& v)
    {
        istr->readAll(v.matchPoolId, v.expectPoolId, v.matchBattleType, v.arenaScore, v.winCount, v.failCount, v.botFixedName, v.onlyBot, v.correctDifficulty, v.activityId, v.activityConfigId, v.faceToken);
    }
};

template<typename S>
struct StreamReader<::squarepro::model::UserTroop, S>
{
    static void read(S* istr, ::squarepro::model::UserTroop& v)
    {
        istr->readAll(v.userId, v.name, v.icon, v.level, v.playerType, v.leaderId, v.leaderSkill, v.heros, v.difficulty, v.logicNodeId, v.matchParams);
    }
};

template<typename S>
struct StreamReader<::squarepro::model::BattleInfo, S>
{
    static void read(S* istr, ::squarepro::model::BattleInfo& v)
    {
        istr->readAll(v.host, v.port, v.battleId);
    }
};

template<typename S>
struct StreamReader<::squarepro::model::BattleTeam, S>
{
    static void read(S* istr, ::squarepro::model::BattleTeam& v)
    {
        istr->readAll(v.userTroop);
    }
};

template<typename S>
struct StreamReader<::squarepro::model::UserStatistics, S>
{
    static void read(S* istr, ::squarepro::model::UserStatistics& v)
    {
        istr->readAll(v.round, v.eliminate, v.skill, v.lordskill, v.level, v.heros, v.arenaScore, v.difficulty, v.conwins);
    }
};

}
/// \endcond

/// \cond INTERNAL
namespace squarepro
{

/// \cond INTERNAL
namespace model
{

using UserTroopPtr = ::std::shared_ptr<UserTroop>;

using UserHeroPtr = ::std::shared_ptr<UserHero>;

using BattleTeamPtr = ::std::shared_ptr<BattleTeam>;

using MatchParamsPtr = ::std::shared_ptr<MatchParams>;

using BattleInfoPtr = ::std::shared_ptr<BattleInfo>;

using UserStatisticsPtr = ::std::shared_ptr<UserStatistics>;

}
/// \endcond

}
/// \endcond

#else // C++98 mapping

namespace IceProxy
{

namespace squarepro
{

namespace model
{

class UserTroop;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< UserTroop>&);
::IceProxy::Ice::Object* upCast(UserTroop*);
/// \endcond

class UserHero;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< UserHero>&);
::IceProxy::Ice::Object* upCast(UserHero*);
/// \endcond

class BattleTeam;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< BattleTeam>&);
::IceProxy::Ice::Object* upCast(BattleTeam*);
/// \endcond

class MatchParams;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< MatchParams>&);
::IceProxy::Ice::Object* upCast(MatchParams*);
/// \endcond

class BattleInfo;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< BattleInfo>&);
::IceProxy::Ice::Object* upCast(BattleInfo*);
/// \endcond

class UserStatistics;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< UserStatistics>&);
::IceProxy::Ice::Object* upCast(UserStatistics*);
/// \endcond

}

}

}

namespace squarepro
{

namespace model
{

class UserTroop;
/// \cond INTERNAL
::Ice::Object* upCast(UserTroop*);
/// \endcond
typedef ::IceInternal::Handle< UserTroop> UserTroopPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::squarepro::model::UserTroop> UserTroopPrx;
typedef UserTroopPrx UserTroopPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(UserTroopPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class UserHero;
/// \cond INTERNAL
::Ice::Object* upCast(UserHero*);
/// \endcond
typedef ::IceInternal::Handle< UserHero> UserHeroPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::squarepro::model::UserHero> UserHeroPrx;
typedef UserHeroPrx UserHeroPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(UserHeroPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class BattleTeam;
/// \cond INTERNAL
::Ice::Object* upCast(BattleTeam*);
/// \endcond
typedef ::IceInternal::Handle< BattleTeam> BattleTeamPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::squarepro::model::BattleTeam> BattleTeamPrx;
typedef BattleTeamPrx BattleTeamPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(BattleTeamPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class MatchParams;
/// \cond INTERNAL
::Ice::Object* upCast(MatchParams*);
/// \endcond
typedef ::IceInternal::Handle< MatchParams> MatchParamsPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::squarepro::model::MatchParams> MatchParamsPrx;
typedef MatchParamsPrx MatchParamsPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(MatchParamsPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class BattleInfo;
/// \cond INTERNAL
::Ice::Object* upCast(BattleInfo*);
/// \endcond
typedef ::IceInternal::Handle< BattleInfo> BattleInfoPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::squarepro::model::BattleInfo> BattleInfoPrx;
typedef BattleInfoPrx BattleInfoPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(BattleInfoPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class UserStatistics;
/// \cond INTERNAL
::Ice::Object* upCast(UserStatistics*);
/// \endcond
typedef ::IceInternal::Handle< UserStatistics> UserStatisticsPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::squarepro::model::UserStatistics> UserStatisticsPrx;
typedef UserStatisticsPrx UserStatisticsPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(UserStatisticsPtr&, const ::Ice::ObjectPtr&);
/// \endcond

}

}

namespace squarepro
{

namespace model
{

typedef ::std::vector<UserTroopPtr> UserTroopLList;

typedef ::std::vector<UserHeroPtr> UserHeroLList;

typedef ::std::vector<BattleTeamPtr> BattleTeamLList;

}

}

namespace squarepro
{

namespace model
{

}

}

namespace IceProxy
{

namespace squarepro
{

namespace model
{

class UserHero : public virtual ::Ice::Proxy<UserHero, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class MatchParams : public virtual ::Ice::Proxy<MatchParams, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class UserTroop : public virtual ::Ice::Proxy<UserTroop, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class BattleInfo : public virtual ::Ice::Proxy<BattleInfo, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class BattleTeam : public virtual ::Ice::Proxy<BattleTeam, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class UserStatistics : public virtual ::Ice::Proxy<UserStatistics, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

}

}

}

namespace squarepro
{

namespace model
{

class UserHero : public virtual ::Ice::Object
{
public:

    typedef UserHeroPrx ProxyType;
    typedef UserHeroPtr PointerType;

    virtual ~UserHero();

    UserHero()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    UserHero(::Ice::Int hid, ::Ice::Int level) :
        hid(hid),
        level(level)
    {
    }

#ifdef ICE_CPP11_COMPILER
    UserHero(const UserHero&) = default;
    UserHero& operator=(const UserHero&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::Ice::Int hid;
    ::Ice::Int level;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_UserHero_init = ::squarepro::model::UserHero::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const UserHero& lhs, const UserHero& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const UserHero& lhs, const UserHero& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class MatchParams : public virtual ::Ice::Object
{
public:

    typedef MatchParamsPrx ProxyType;
    typedef MatchParamsPtr PointerType;

    virtual ~MatchParams();

    MatchParams()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    MatchParams(::Ice::Int matchPoolId, ::Ice::Int expectPoolId, ::Ice::Int matchBattleType, ::Ice::Int arenaScore, ::Ice::Int winCount, ::Ice::Int failCount, bool botFixedName, bool onlyBot, ::Ice::Int correctDifficulty, ::Ice::Long activityId, ::Ice::Int activityConfigId, const ::std::string& faceToken) :
        matchPoolId(matchPoolId),
        expectPoolId(expectPoolId),
        matchBattleType(matchBattleType),
        arenaScore(arenaScore),
        winCount(winCount),
        failCount(failCount),
        botFixedName(botFixedName),
        onlyBot(onlyBot),
        correctDifficulty(correctDifficulty),
        activityId(activityId),
        activityConfigId(activityConfigId),
        faceToken(faceToken)
    {
    }

#ifdef ICE_CPP11_COMPILER
    MatchParams(const MatchParams&) = default;
    MatchParams& operator=(const MatchParams&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::Ice::Int matchPoolId;
    ::Ice::Int expectPoolId;
    ::Ice::Int matchBattleType;
    ::Ice::Int arenaScore;
    ::Ice::Int winCount;
    ::Ice::Int failCount;
    bool botFixedName;
    bool onlyBot;
    ::Ice::Int correctDifficulty;
    ::Ice::Long activityId;
    ::Ice::Int activityConfigId;
    ::std::string faceToken;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_MatchParams_init = ::squarepro::model::MatchParams::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const MatchParams& lhs, const MatchParams& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const MatchParams& lhs, const MatchParams& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class UserTroop : public virtual ::Ice::Object, public ::IceInternal::GCObject
{
public:

    typedef UserTroopPrx ProxyType;
    typedef UserTroopPtr PointerType;

    virtual ~UserTroop();

    UserTroop()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    UserTroop(::Ice::Long userId, const ::std::string& name, const ::std::string& icon, ::Ice::Int level, ::Ice::Int playerType, ::Ice::Int leaderId, ::Ice::Int leaderSkill, const ::squarepro::model::UserHeroLList& heros, ::Ice::Int difficulty, const ::std::string& logicNodeId, const ::squarepro::model::MatchParamsPtr& matchParams) :
        userId(userId),
        name(name),
        icon(icon),
        level(level),
        playerType(playerType),
        leaderId(leaderId),
        leaderSkill(leaderSkill),
        heros(heros),
        difficulty(difficulty),
        logicNodeId(logicNodeId),
        matchParams(matchParams)
    {
    }

#ifdef ICE_CPP11_COMPILER
    UserTroop(const UserTroop&) = default;
    UserTroop& operator=(const UserTroop&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
    /// \cond INTERNAL
    virtual void _iceGcVisitMembers(::IceInternal::GCVisitor&);
    /// \endcond

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::Ice::Long userId;
    ::std::string name;
    ::std::string icon;
    ::Ice::Int level;
    ::Ice::Int playerType;
    ::Ice::Int leaderId;
    ::Ice::Int leaderSkill;
    ::squarepro::model::UserHeroLList heros;
    ::Ice::Int difficulty;
    ::std::string logicNodeId;
    ::squarepro::model::MatchParamsPtr matchParams;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_UserTroop_init = ::squarepro::model::UserTroop::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const UserTroop& lhs, const UserTroop& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const UserTroop& lhs, const UserTroop& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class BattleInfo : public virtual ::Ice::Object
{
public:

    typedef BattleInfoPrx ProxyType;
    typedef BattleInfoPtr PointerType;

    virtual ~BattleInfo();

    BattleInfo()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    BattleInfo(const ::std::string& host, ::Ice::Int port, ::Ice::Long battleId) :
        host(host),
        port(port),
        battleId(battleId)
    {
    }

#ifdef ICE_CPP11_COMPILER
    BattleInfo(const BattleInfo&) = default;
    BattleInfo& operator=(const BattleInfo&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::std::string host;
    ::Ice::Int port;
    ::Ice::Long battleId;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_BattleInfo_init = ::squarepro::model::BattleInfo::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const BattleInfo& lhs, const BattleInfo& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const BattleInfo& lhs, const BattleInfo& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class BattleTeam : public virtual ::Ice::Object, public ::IceInternal::GCObject
{
public:

    typedef BattleTeamPrx ProxyType;
    typedef BattleTeamPtr PointerType;

    virtual ~BattleTeam();

    BattleTeam()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit BattleTeam(const ::squarepro::model::UserTroopPtr& userTroop) :
        userTroop(userTroop)
    {
    }

#ifdef ICE_CPP11_COMPILER
    BattleTeam(const BattleTeam&) = default;
    BattleTeam& operator=(const BattleTeam&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
    /// \cond INTERNAL
    virtual void _iceGcVisitMembers(::IceInternal::GCVisitor&);
    /// \endcond

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::squarepro::model::UserTroopPtr userTroop;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_BattleTeam_init = ::squarepro::model::BattleTeam::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const BattleTeam& lhs, const BattleTeam& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const BattleTeam& lhs, const BattleTeam& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class UserStatistics : public virtual ::Ice::Object, public ::IceInternal::GCObject
{
public:

    typedef UserStatisticsPrx ProxyType;
    typedef UserStatisticsPtr PointerType;

    virtual ~UserStatistics();

    UserStatistics()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    UserStatistics(::Ice::Int round, ::Ice::Int eliminate, ::Ice::Int skill, ::Ice::Int lordskill, ::Ice::Int level, const ::squarepro::model::UserHeroLList& heros, ::Ice::Int arenaScore, ::Ice::Int difficulty, ::Ice::Int conwins) :
        round(round),
        eliminate(eliminate),
        skill(skill),
        lordskill(lordskill),
        level(level),
        heros(heros),
        arenaScore(arenaScore),
        difficulty(difficulty),
        conwins(conwins)
    {
    }

#ifdef ICE_CPP11_COMPILER
    UserStatistics(const UserStatistics&) = default;
    UserStatistics& operator=(const UserStatistics&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
    /// \cond INTERNAL
    virtual void _iceGcVisitMembers(::IceInternal::GCVisitor&);
    /// \endcond

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::Ice::Int round;
    ::Ice::Int eliminate;
    ::Ice::Int skill;
    ::Ice::Int lordskill;
    ::Ice::Int level;
    ::squarepro::model::UserHeroLList heros;
    ::Ice::Int arenaScore;
    ::Ice::Int difficulty;
    ::Ice::Int conwins;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_UserStatistics_init = ::squarepro::model::UserStatistics::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const UserStatistics& lhs, const UserStatistics& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const UserStatistics& lhs, const UserStatistics& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

}

}

/// \cond STREAM
namespace Ice
{

template<typename S>
struct StreamWriter< ::squarepro::model::UserHero, S>
{
    static void write(S* ostr, const ::squarepro::model::UserHero& v)
    {
        ostr->write(v.hid);
        ostr->write(v.level);
    }
};

template<typename S>
struct StreamReader< ::squarepro::model::UserHero, S>
{
    static void read(S* istr, ::squarepro::model::UserHero& v)
    {
        istr->read(v.hid);
        istr->read(v.level);
    }
};

template<typename S>
struct StreamWriter< ::squarepro::model::MatchParams, S>
{
    static void write(S* ostr, const ::squarepro::model::MatchParams& v)
    {
        ostr->write(v.matchPoolId);
        ostr->write(v.expectPoolId);
        ostr->write(v.matchBattleType);
        ostr->write(v.arenaScore);
        ostr->write(v.winCount);
        ostr->write(v.failCount);
        ostr->write(v.botFixedName);
        ostr->write(v.onlyBot);
        ostr->write(v.correctDifficulty);
        ostr->write(v.activityId);
        ostr->write(v.activityConfigId);
        ostr->write(v.faceToken);
    }
};

template<typename S>
struct StreamReader< ::squarepro::model::MatchParams, S>
{
    static void read(S* istr, ::squarepro::model::MatchParams& v)
    {
        istr->read(v.matchPoolId);
        istr->read(v.expectPoolId);
        istr->read(v.matchBattleType);
        istr->read(v.arenaScore);
        istr->read(v.winCount);
        istr->read(v.failCount);
        istr->read(v.botFixedName);
        istr->read(v.onlyBot);
        istr->read(v.correctDifficulty);
        istr->read(v.activityId);
        istr->read(v.activityConfigId);
        istr->read(v.faceToken);
    }
};

template<typename S>
struct StreamWriter< ::squarepro::model::UserTroop, S>
{
    static void write(S* ostr, const ::squarepro::model::UserTroop& v)
    {
        ostr->write(v.userId);
        ostr->write(v.name);
        ostr->write(v.icon);
        ostr->write(v.level);
        ostr->write(v.playerType);
        ostr->write(v.leaderId);
        ostr->write(v.leaderSkill);
        ostr->write(v.heros);
        ostr->write(v.difficulty);
        ostr->write(v.logicNodeId);
        ostr->write(v.matchParams);
    }
};

template<typename S>
struct StreamReader< ::squarepro::model::UserTroop, S>
{
    static void read(S* istr, ::squarepro::model::UserTroop& v)
    {
        istr->read(v.userId);
        istr->read(v.name);
        istr->read(v.icon);
        istr->read(v.level);
        istr->read(v.playerType);
        istr->read(v.leaderId);
        istr->read(v.leaderSkill);
        istr->read(v.heros);
        istr->read(v.difficulty);
        istr->read(v.logicNodeId);
        istr->read(v.matchParams);
    }
};

template<typename S>
struct StreamWriter< ::squarepro::model::BattleInfo, S>
{
    static void write(S* ostr, const ::squarepro::model::BattleInfo& v)
    {
        ostr->write(v.host);
        ostr->write(v.port);
        ostr->write(v.battleId);
    }
};

template<typename S>
struct StreamReader< ::squarepro::model::BattleInfo, S>
{
    static void read(S* istr, ::squarepro::model::BattleInfo& v)
    {
        istr->read(v.host);
        istr->read(v.port);
        istr->read(v.battleId);
    }
};

template<typename S>
struct StreamWriter< ::squarepro::model::BattleTeam, S>
{
    static void write(S* ostr, const ::squarepro::model::BattleTeam& v)
    {
        ostr->write(v.userTroop);
    }
};

template<typename S>
struct StreamReader< ::squarepro::model::BattleTeam, S>
{
    static void read(S* istr, ::squarepro::model::BattleTeam& v)
    {
        istr->read(v.userTroop);
    }
};

template<typename S>
struct StreamWriter< ::squarepro::model::UserStatistics, S>
{
    static void write(S* ostr, const ::squarepro::model::UserStatistics& v)
    {
        ostr->write(v.round);
        ostr->write(v.eliminate);
        ostr->write(v.skill);
        ostr->write(v.lordskill);
        ostr->write(v.level);
        ostr->write(v.heros);
        ostr->write(v.arenaScore);
        ostr->write(v.difficulty);
        ostr->write(v.conwins);
    }
};

template<typename S>
struct StreamReader< ::squarepro::model::UserStatistics, S>
{
    static void read(S* istr, ::squarepro::model::UserStatistics& v)
    {
        istr->read(v.round);
        istr->read(v.eliminate);
        istr->read(v.skill);
        istr->read(v.lordskill);
        istr->read(v.level);
        istr->read(v.heros);
        istr->read(v.arenaScore);
        istr->read(v.difficulty);
        istr->read(v.conwins);
    }
};

}
/// \endcond

namespace squarepro
{

namespace model
{

}

}

#endif

#include <IceUtil/PopDisableWarnings.h>
#endif
